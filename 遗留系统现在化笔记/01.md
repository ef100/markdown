# 遗留系统现代化实战笔记 

## 总结

### 要点

- 十六字心法：
  - 旧的不变，新的创建。一步切换，旧的再见

- 重构方式：
  - 绞杀植物：替换老系统或服务
  - 气泡上下文：隔离新需求和老服务
  - 修缮者模式：替换老系统内部的模块
  - 抽象分支：使用抽象层来替换模块、类、方法
  - 扩张收缩：模块、类、方法，针对接口无法兼容的



### 概念：

- 结缝：可以让 DOC 的行为发生改变的位置，叫做接缝（seam)
- - 


<img src="%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0.assets/image-20220522200213879.png" alt="image-20220522200213879" style="zoom: 33%;" />

## 开篇词(1讲)

## 基础篇 (2讲)

## 原则篇 (4讲)

## 模式篇 (12讲)

### 08 | 代码现代化：你的代码可测吗？

- SUT（System Under Test）

- DOC（Depended-on Component）

#### DOC 不可用的原因通常有3种：

> 主要还是DB之类的

1. <u>不能访问</u>。如数据库、服务，本地环境没有这些组件，也很难部署这些组件。
1. <u>不是当前测试期望的返回值</u>。即使本地能够访问这些组件，但它们却无法返回我们想要的值。比如我们想要获取 ID 为 1 的员工信息，但数据库中却并没有这条数据。
1. 执行这些 DOC 的方法会<u>引发不想要的副作用</u>。比如更新数据库，会破坏已有数据，影响其他测试。另外连接数据库，还会导致测试执行时间变长，这也是一种副作用。

如何让代码变得可测？

我把这种在 SUT 中创建接缝从而使 SUT 变得可测的方式，叫做<u>提取接缝模式</u>。

#### 接缝的位置(注入方式)

- 构造函数注入
- 方法参数
- 字段

#### 接缝的类型

- 对象接缝 - 通过继承 DOC 来改变默认行为
- 接口接缝 - 通过将 DOC 提取为接口，并用其他实现类来改变默认行为

#### 新生和外覆

> 虽然接缝很好，但是很多复杂的代码依赖了太多东西，一个个都提取接缝的话，需要很长时间，但无奈工期太紧，不允许这么做啊。

- 新生（sprout）
  - 新加的逻辑，封装到一个新方法里，让老方法调用新方法
  - 这样一来，新生方法是可测的，你可以对它添加测试，以验证过滤逻辑的正确性。原来的方法虽然仍然不可测，但我们也没有让它变得更糟。

- 外覆（wrap）
  - 新增一个方法，它会先调用原有方法，然后再调用通知方法。
  - 通过这样的修改，调用端只需要根据情况选择调用哪个方法即可，这样的改动量最少。同时你还可以单独测试 notifyEmployee，以确保这部分逻辑是正确的。

#### 测试替身（Test Double）

Mock 框架：制作测试替身(Fake/Mock)

在多大程度上使用测试替身

- 社恐症单元测试

- 交际花单元测试 
  - 我个人更倾向于交际花单测，因为这样写起来更容易，而且对重构很友好。

#### 决策表模式

![img](%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0.assets/6357f689162820db3d22623e38aacbd1.jpg)

#### 遗留系统中的测试策略



### 11 | 架构现代化 ：在气泡上下文中打造你的新城区

* 绞杀植物模式 Strangler Fig
* 气泡上下文
* 防腐层（Anticorruption Layer）
  * 避免一个上下文中的模型渗透到另一个上下文中
* 自治气泡
* 变动数据捕获(CDC)
  * 事件拦截
  * 遗留系统封装 API

<img src="%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0.assets/image-20220522200213879.png" alt="image-20220522200213879" style="zoom: 33%;" />



### 12 | 架构现代化 ：微服务，你准备好了吗？

基于组件的单体架构 ➔ 基于服务的分布式架构 ➔ 微服务架构

- 单体和微服务应该如何取舍？

  - 正确的方案可能要这样演进：先拆出一个不太大的服务，抽出 2 到 3 名开发人员组成新的团队来维护它，然后再慢慢扩张团队，并逐渐拆出新的服务，直到形成一个 5 到 9 人的团队维护一个服务这样的比例为止。

  

#### 单体向微服务的演进

##### 基于组件的单体架构

- 要想改善大泥球架构，最重要的就是把业务模块之间的耦合解开，<u>消除掉模块间的相互依赖关系</u>。同时，也要将数据的所有权分开，<u>让不同的模块拥有不同的数据</u>。这种类型的单体架构我们称之为基于组件的单体架构。

> 比如销售模块不可能不依赖库存数据。在大泥球中的做法，当然是在销售模块中直接访问库存表，但在基于组件的单体架构中，我们要让<u>库存模块提供一个外部模块可以访问的接口</u>（非 Web API），销售模块<u>通过防腐层</u>去调用这个接口，转换成销售业务所需要的库存数据。这样，销售模块就不再直接依赖库存数据表了。
>
> 通过防腐层对不同模块进行了隔离，一个模块中模型的修改，不会影响到另一个模块。
>
> 如果大泥球的模块之间比较好解耦，你就可以先将其中一个模块解耦出来，再逐步把其他模块也一一照方抓药。

<img src="%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0.assets/6c53c70458cyy598730b2b554c70c66a.jpg" alt="img" style="zoom:33%;" />

##### 基于服务的分布式架构

> 当<u>单体内的模块</u>清晰之后，你会发现一些模块描述的是一个<u>大的业务领域</u>，你可以尝试按业务领域给这些模块分组，将它们拆分出来，形成服务。这种架构叫做基于服务的分布式架构。

![img](%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0.assets/e0d51a4a7318c6b0921a4c8ce358b420.jpg)

##### 微服务架构

> 当各个模块及其数据库的弹性边界都不同时，就拆分出了微服务架构。
>
> 在微服务架构下，业务边界变得十分清晰，每个服务可以独立部署和演进，并且可以选择不同的技术栈。一个团队只负责一个或少量的服务（业务模块），可以更好地守护住这个服务不被外界腐化。同时由于关注点比较聚焦，认知负载也得到了降低。
>
> 微服务架构虽然降低了开发人员的认知负载，但却提升了运维人员的认知负载。它实际上是用运维复杂度来置换开发复杂度。开发人员所面对的内容少了，更加聚焦了，但运维人员却从以前运维一个单体服务，变为运维几个甚至几十个上百个微服务。这需要<u>强有力的 DevOps</u> 文化作为支撑。

![img](%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0.assets/6f6d7a4991d13f81c23aafefd66babyy.jpg)

#### 遗留系统的架构应该如何演进？

![img](%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0.assets/7ee273927836c8ae9b1faa38c710a58c.jpg)

##### 基于组件的分解

基于组件的分解模式适合将单体架构迁移到基于服务的分布式架构上，这往往是我们迈向微服务架构的第一步。

1. 识别和调整组件大小：统计各个模块的代码语句数，拆分那些过于庞大的组件，使所有组件的语句数趋于一致。
2. 收集公共领域组件：在基于组件的单体架构中，很多组件的功能是类似的，比如邮件通知和短信通知，或者订单通知模块和物流通知模块。识别这些模块并进行合并，有助于消除重复。
3. 展平组件：让组件中的类都位于叶子节点的包中，不要出现孤儿类（即类和其他包平级）。
4. 明确组件依赖：分析组件之间的依赖关系。
5. 构建领域组件：在逻辑上将属于同一领域的组件组合在一起。
6. 创建领域服务：当组件的大小适中、结构扁平，并且按领域分组后，就可以在此基础上拆分出领域服务，构建基于服务的分布式架构了。

> 要完成一个简单的业务场景，需要有一个<u>编排服务</u>来编排多个<u>实体服务</u>，这导致<u>业务逻辑位于编排服务中</u>，而不是微服务中；一个常见的业务需求，都可能会涉及多个实体服务的修改，这就导致服务无法独立部署，只能多个服务或整体一起部署。这样一来，就跟单体架构没有区别了，甚至更糟，因为它还是分布式的。我们管这种架构叫做分布式单体（Distributed Monolith）。

##### 战术分叉

> 如果一个大泥球单体架构中，连相对清晰的组件边界都没有，所有代码混在一起，这种情况拆分起来会十分困难。通常来说，当我们考虑从一个大的整体中，把一个小的部分挪出去的时候，方法都是“拆”。但当“拆”不动的时候，你可以变换一下思路，用“删”的方式来实现拆分。这种模式，就叫做战术分叉。

怎么删呢？我们先把系统<u>整体复制一份</u>，然后在复制出来的系统中<u>删掉不需要的代码</u>，保留下来的就是我们希望拆分出来的部分了。在系统之上，你需要构建一个反向代理，根据请求来判断，需要转发给原来的系统，还是复制出来的分叉系统。

![img](%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0.assets/54f3ea8c4471f468a50731408f206542.jpg)



参考：

- https://www.youtube.com/watch?v=haejb5rzKsM

### 13 | 架构现代化 ：如何改造老城区前端？

重构前端代码

* 第一步，梳理业务
* 第二步，模块化
* 第三步，重构 JSP 中的 JavaScript 代码
* 第四步，移除 JSP 中的 Java 代码
* 第五步，引入前端框架
* 第七步，前端工程化
* 第八步，API 治理
* ![img](%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0.assets/c671068a2e4f5c26e57a93a9728ecc4a.jpg)

### 14 | 架构现代化 ：如何改造老城区后端？

- 在气泡上下文中开发新的需求
  - 类似于老城区旁边建设一个新城区
- 在遗留系统中开发新的需求
  - 类似于在老城区内部开发新的楼盘

#### 修缮者模式

复制旧代码(维持老功能)➔开关指向副本➔修改旧代码➔删除副本

> 在修缮时，我们通过开关隔离旧系统待修缮的部分，并采用新的方式修改。在修缮的过程中，模块仍然能通过开关对外提供完整功能。
>
> 我们可以将道路（待修缮的模块）“复制”出来一份，以保障通行正常。等原道路修缮好之后，再删除掉复制出来的道路即可。
>
> 这样做的好处是，由于你无法预测修缮过程中会产生哪些问题，这种通过开关<u>保留回退余地</u>的方法，显然是更灵活的。

![img](%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0.assets/4efdb7aa98481f6096a665cfd514484a.jpg)

#### 抽象分支⭐

> 抽象分支（Branch by Absctration），这种优雅的方式就是，把要重构的方法重构成一个<u>方法对象</u>，然后提取出<u>一个接口</u>，待重构的方法是接口的<u>一个实现</u>，重构后的方法是<u>另一个实现</u>

这个替换是逐步进行的，不是一次性全部替换掉。<u>等全部调用端都依赖抽象层后</u>，开始编写新的实现，并让部分模块使用新的实现。这个过程也是逐步进行的，一方面可以更好地验证新实现，另一方面也可以随时回退。当全部调用端都使用新的实现后，再删除旧的实现

![img](%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0.assets/63cbe62a638d900d6acb31aa3081775e.jpg)

由于新代码一直可以工作，因此你可以不断提交、不断交付、不断验证。

如何优雅地替换一个实现：https://mp.weixin.qq.com/s/X_7RC567aYrrO_MzykmdRQ

#### 扩张与收缩

> 这时你可以使用扩张 - 收缩（expand-contract）模式，也叫并行修改（Parallel Change）模式。它一般包含三个步骤，即扩张、迁移和收缩。这里的扩张是指建立新的接口，它相比原来旧的代码新增了一些东西，因此叫做“扩张”；而收缩是指删除旧的接口，它比之前减少了一些东西，因此叫“收缩”。
>
> 一般来说，它会在类的内部新建一些方法，以提供新的接口（即扩张），然后再逐步让调用端使用新的接口（即迁移），当所有调用端都使用新的接口后，就删除旧的接口（即收缩）。

![img](%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0.assets/362de65418e023394bd7ce1bc6c1baba.jpg)

#### 再谈接缝

接缝不但可以用来在测试中替换已有的实现，它本身其实也是一个业务变化的方向。

> 比如你的项目中使用了 RabbitMQ 作为消息中间件，发送和接受消息的代码<u>和 RabbitMQ 的 SDK 紧密耦合</u>，这会带来两方面隐患，一方面当你想<u>替换 MQ</u> 的时候，需要修改全部调用点，另一方面，它也<u>不好写测试</u>。

当需要替换 MQ 的时候，只需要提供一套新的实现类。这时的实现类应该叫做适配器（Adaptor），它其实也起到了防腐层的作用

#### 总结

无论是绞杀植物、修缮者、抽象分支还是扩张收缩，它们在实施的过程中，都允许新旧实现并存，这种思想叫做<u>并行运行</u>（Parallel Run）。这是我们贯彻增量演进原则的基本思想

十六字心法：旧的不变，新的创建，一步切换，旧的，再见。

![img](%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0.assets/cb88b22aa60de6224abe96325592a66b.jpg)


